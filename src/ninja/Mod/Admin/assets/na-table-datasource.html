<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../core-ajax/core-ajax.html">
<link rel="import" href="na-field.html">
<polymer-element
	name="na-table-datasource"
	attributes="
		endPoint
		model
	"
>
	<script>
		Polymer('na-table-datasource', {
			endPoint: null,
			model: null,
			meta: null,
			DEFAULT_PAGE_SIZE: 20,
			// sortable-table-datasource attributes
			start: 0,
			length: null,
			search: null,
			sortColumn: null,
			sortDescending: false,
			filters: [],
			// you can set this from the outside
			columns: [],
			// I will use this internally
			fieldNames: [],
//			columnsObserver: null,
			filterOps: null,
			loading: false,
			data: [],
			dataSize: null,
			ajax: null,
			// I'll store last ajax call params here so if eg. columns change, I can check if there is need for a reload
			lastAjaxData: null,
			ready: function() {

				var ajax = document.createElement('core-ajax');
				ajax.handleAs = 'json';
				var that = this;
				ajax.addEventListener("core-response", function(e){ that.handleResponse.call(that, e); });
				this.ajax = ajax;
				// I do not call go here as it will be triggered otherwise
				//this.fireGoJobFn()();

				// I set up debounced go() on change of any of these properties
				(new PathObserver(this, 'start')).open(this.fireGoJobFn());
				(new PathObserver(this, 'length')).open(this.fireGoJobFn());
				(new PathObserver(this, 'search')).open(this.fireGoJobFn());
				(new PathObserver(this, 'sortColumn')).open(this.fireGoJobFn());
				(new PathObserver(this, 'sortDescending')).open(this.fireGoJobFn());
				(new PathObserver(this, 'filters')).open(this.fireGoJobFn());
				// I remove this as column change might happen after a load and that would trigger another request
//				this.columnsObserver = new PathObserver(this, 'columns');
//				this.columnsObserver.open(this.columnsChangedHandler);
				(new PathObserver(this, 'columns')).open(this.columnsChangedHandler);
				this.fieldNamesObserver = new PathObserver(this, 'fieldNames');
				this.fieldNamesObserver.open(this.fireGoJobFn());
				//(new PathObserver(this, 'filterOps')).open(this.fireGoJobFn());
			},
			/**
			 * I return a function that initiates a this.go() but debounced for 200ms
			 */
			fireGoJobFn: function() {
				var that = this;
				return function() {
					that.job('go', that.go, 1000);
				}
			},
			/**
			 * I will set up this.dataSize, this.meta, this.data
			 */
			handleResponse: function(e) {
				var response = e.detail.response;
				this.dataSize = response.allCount;
				if (response.meta && !this.meta) {
					// go will fire because sortable-table will find the meta change
					this.meta = response.meta;
					this.fire('metaChanged');
				}
				if (this.fieldNames.length > 0) {
					var data = [];
					for (var i in response.result) {
						if (response.result.hasOwnProperty(i)) {
							var obj = {};
							this.fieldNames.forEach(function(column) {
								var j = 1;
//								obj[column.name] = response.result[i][column.name];
								obj[column] = response.result[i][column];
							});
							data.push(obj);
						}
					}
					this.data = data;
				}
				else {
					this.data = response.result;
				}
			},
			/**
			 *  note this handler contains some optimizations. the original goal was to overcome a bug/strange behavior
			 *  	in sortable-table which does not set the columns before the first load (but does set after the load
			 *  	happens). this might be due to the order in which elements are initialized, however, such an
			 *  	optimization is always good ;)
			 */
			columnsChangedHandler: function(newValue, oldValue, observer) {
				var that = observer.object_,
					newMappedValue = newValue.map(function(column) { return column.name; });

				// first, apply silently the new mapped value to fieldNames
				if (that.fieldNamesObserver) {
					that.fieldNamesObserver.disconnect_();
					that.fieldNames = newMappedValue;
					that.fieldNamesObserver.connect_();
				}
				else {
					that.fieldNames = newMappedValue;
				}

				// check if this change in field names shall trigger a reload?
				var needReload = false;
				if (!newValue.length && oldValue.length) {
					needReload = true;
				}
				else if (newValue.length && oldValue.length) {
					newValue.forEach(function(eachNewFieldName) {
						if (oldValue.indexOf(eachNewFieldName) == -1) {
							needReload = true;
						}
					});
				}

				// and trigger only if needed
				if (needReload) {
					that.fireGoJobFn()();
				}
			},
			go: function() {
				//console.log('GO!', this.start, this.length, this.search, this.sortColumn, this.sortDescending, this.filters, this.fieldNames);

				// @todo this shall be some more sophisticated logging... eg. emit a log event and always init a global watcher
				if (!this.endPoint || !this.model) {
					return console.log('no endPoint or/nor model set:', this.endPoint, '/', this.model);
				}

				var url = [
					this.endPoint || '',
					this.meta === null ? 'withMeta' : '',
					this.model || ''
				];
				var params = {
					start: this.start
				};
				var that = this;
				if (this.length !== null && this.length!==Number.MAX_VALUE) {
					params.length = this.length;
				}
				else {
					params.length = this.DEFAULT_PAGE_SIZE;
				}
				/*
				if (this.sortColumn){
					var dir = this.sortDescending ? 'DESC' : 'ASC';
					params.sort = JSON.stringify([{ property: this.sortColumn, direction: dir }]);
					params.sort = (this.sortDescending ? '-' : '') + this.sortColumn;
				}
				if (this.filters && this.filters.length > 0){
					params.filter = JSON.stringify(this.filters.map(function(filter){
						return { "comparison": filter.op, "value":filter.value, "field": filter.column, "type": "numeric" };
					}));
				}
				*/
				if (this.fieldNames.length) {
					params._fields = this.fieldNames;
				}

				// now we have params to call, check if reload is needed?
				this.ajax.url = this.joinPath(url);
				this.ajax.params = params;
				this.lastAjaxData = {
					url: url,
					params: params
				};
				this.isLoading = true;

				this.ajax.go();
			},
			joinPath: function(arr) {
				var i, tmp, ret=[];
				for (i in arr) {
					if (!arr.hasOwnProperty(i)) {
						continue;
					}
					tmp = arr[i].replace(/^\//, '').replace(/\/$/, '');
					if (tmp !== '') {
						ret.push(tmp);
					}
				}
				return ret.join('/');
			}
		});
	</script>
</polymer-element>
